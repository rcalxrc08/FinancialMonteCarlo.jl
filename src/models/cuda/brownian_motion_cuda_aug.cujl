
function simulate!(X_cu, mcProcess::BrownianMotionVec, mcBaseData::MonteCarloConfiguration{type1, type2, type3, CudaMode, type5}, T::numb) where {numb <: Number, type1 <: Number, type2 <: Number, type3 <: StandardMC, type5 <: Random.AbstractRNG}
    Nsim = mcBaseData.Nsim
    Nstep = mcBaseData.Nstep

    σ = mcProcess.σ
    μ = mcProcess.μ
    @assert T > 0
    dt = T / Nstep
    mean_bm = μ * dt
    stddev_bm = σ * sqrt(dt)
    isDualZero = mean_bm * stddev_bm * 0
    Z = CuArray{Float32}(undef, Nsim)
    for i = 1:Nstep
        X_pr = view(X_cu, :, i)
        tmp_ = incremental_integral(μ, (i - 1) * dt, dt)
        randn!(CUDA.CURAND.default_rng(), Z)
        @inbounds X_cu[:, i+1] = X_pr + (tmp_ .+ stddev_bm * Z)
    end
    return
end

function simulate!(X_cu, mcProcess::BrownianMotionVec, mcBaseData::MonteCarloConfiguration{type1, type2, type3, CudaMode, type5}, T::numb) where {numb <: Number, type1 <: Number, type2 <: Number, type3 <: AntitheticMC, type5 <: Random.AbstractRNG}
    Nsim = mcBaseData.Nsim
    Nstep = mcBaseData.Nstep

    σ = mcProcess.σ
    μ = mcProcess.μ
    @assert T > 0
    dt = T / Nstep
    mean_bm = μ * dt
    stddev_bm = σ * sqrt(dt)
    isDualZero = mean_bm * stddev_bm * zero(Float32)
    Nsim_2 = div(Nsim, 2)
    X_cu_p = view(X_cu, 1:Nsim_2, :)
    X_cu_m = view(X_cu, (Nsim_2+1):Nsim, :)
    Z = CuArray{Float32}(undef, Nsim_2)

    for i = 1:Nstep
        randn!(CUDA.CURAND.default_rng(), Z)
        tmp_ = incremental_integral(μ, (i - 1) * dt, dt)
        @views X_cu_p[:, i+1] = X_cu_p[:, i] + (tmp_ .+ stddev_bm .* Z)
        @views X_cu_m[:, i+1] = X_cu_m[:, i] + (tmp_ .- stddev_bm .* Z)
    end
    return
end
